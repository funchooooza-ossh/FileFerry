# ADR - 0005: Избавление от снежного lazy init кома.

## Статус
Принято

## Контекст
Во время активной разработки инфраструктурного слоя был порождён костыль
из-за особенности работы SQLAlchemy => моего SQL data access слоя +
желания использовать предзаготовленные DI контейнеры.
Суть его была такой: соберем data access, а сессию в БД прокинем потом.
В итоге при реализации cache aside через Redis я получил проблему:
теперь в конфигурации с кэшем Cached Data Access обёртка должна прокидывать сессию
внутрь своего делегата(SQL data access слоя), но я не хотел нарушать инкапсуляцию логики.
В итоге было решено: мы это выпиливаем.

## Решение
В dependency-injectors есть такой provider, как ContextLocalSingleton,
своего рода scoped(по сути это он и есть).
С помощью него я получал строго одну сессию на один контест(потокобезопасно),
сессия передавалась в Coordination-layer и в SQL data access layer.
После чего, когда этого требовал слой приложения: вход в контекст координатора,
сессия начиналась внутри координатора => начиналась внутри data access.

## Альтернативы
- Оставить, как есть. Жуткое решение, необоснованно убить расширяемость и инкапсуляцию не в моих интересах.


## Итоги
- Потокобезопасная сессия в рамках одного контекста.
- Легко расширять и заворачивать data access в любые обертки.
- Экономия ресурсов базы, ведь теперь можно брать из пула только одну сессию и использовать.
