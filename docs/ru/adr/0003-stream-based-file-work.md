# ADR-0003: Stream-based Endpoints для REST-интеграций

## Контекст

В процессе разработки микросервиса FileFerry возникла необходимость интеграции с внешними REST-сервисами, которые предполагают передачу бинарных данных напрямую в теле запроса, без использования multipart/form-data.

Передача файлов через multipart неприемлема в этом контексте:

- это избыточно по накладным расходам;
- это сложно для интеграции на стороне некоторых клиентов (например, сервисов на Node.js, Java);
- невозможно встраивать стриминговую обработку без промежуточного хранения.

Поэтому было принято решение **поддерживать стримовую загрузку/обновление файлов** через `request.stream()` в FastAPI.

## Решение

### Архитектурная готовность

Изначально архитектура работы с файлами была выстроена с опорой на асинхронные байтовые потоки:

```python
stream: AsyncIterator[bytes]
```

Это решение было выбрано **заранее**, с расчётом на отказ от загрузки файлов целиком в память (InMemory) и потенциальную стримовую природу интеграций.

**Преимущества AsyncIterator[bytes]:**

- одинаково хорошо работает и с `UploadFile.file`, и с `request.stream()`;
- не требует переписывания usecase'ов при смене источника данных;
- позволяет обрабатывать большие файлы без переполнения памяти.

### Изменения

- Были добавлены новые endpoint'ы: `stream_upload` и `stream_update`, принимающие `request: Request` и извлекающие `stream = request.stream()`.
- Ни один существующий UseCase, Adapter или Domain объект **не был изменён**.
- Новый endpoint просто адаптирует входящий `request.stream()` в тип `AsyncIterator[bytes]` и передаёт его в существующий usecase.

## Пример

```python
@router.post("/api/v1/files/stream")
async def stream_upload(
    request: Request,
    adapter: FileAdapter = Depends(...),
):
    stream = request.stream()
    return await adapter.upload(name=..., stream=stream, bucket=...)
```

## Результаты

- **OCP соблюдён**: поведение расширено, а не изменено.
- **Высокая гибкость**: можно обрабатывать любые источники бинарных данных.
- **Память не перегружается**: вся цепочка от приёма до сохранения поддерживает стримы.
- **Инфраструктура не изменялась**: адаптеры, usecases и storage-клиенты остались без модификаций.

## Вывод

Это решение демонстрирует, что правильно спроектированная архитектура (асинхронные потоки, интерфейсное программирование, адаптеры и usecase'ы, изолированные от источника данных) позволяет **добавлять сложные сценарии без боли и модификации ядра**.

Функциональность стримовой загрузки/обновления появилась естественным путём, как следствие изначального инженерного выбора.

