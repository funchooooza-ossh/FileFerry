# ADR-0004: Внедрение Redis Cache для оптимизации запросов к метаданным файлов

## Статус
Принято

## Контекст
В сервисе FileFerry метаданные файлов (объект `FileMeta`) используются для описания каждого файла и при получении, и при обработке загрузки/удаления. Ранее вся эта логика основывалась исключительно на SQLAlchemy (PostgreSQL), что вело к нерациональному использованию пула сессий и времени отклика при высокой частоте GET-запросов.

## Решение
Была введена Redis-обертка (`RedisDataAccess`) по паттерну **Cache Aside**. Она позволяет:

1. При чтении: проверять Redis перед обращением к PostgreSQL;
2. При записи/обновлении: обновлять Redis после успеха в SQL;
3. При удалении: очищать Redis после SQL.

Для инициализации SQL DAO и Redis DAO был сохранён **lazy-init**, похожий на имеющуюся логику TransactionManager. Вызов `bind_delegate(...)` происходит после запуска транзакции.

## Альтернативы
- Кеш-прокси вокруг хранилища (MinIO/S3) — бессмысленен: зачастую надо противоположное.
- Кеш отдельно от DAO — повышает нагрузку и раздувает код в usecase.

## Итоги
- Реализован оберточный Redis DAO;
- Выбран подход Cache-Aside;
- Обеспечен fail-safety (ошибки Redis не влияют на business-flow);
- Оценка выгод: снижение latency GET на 30–50% и разгрузка базы при повторных запросах.

